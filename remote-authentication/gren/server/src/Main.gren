module Main exposing (main)

import Bytes exposing (Bytes)
import Bytes.Decode as BytesDecode
import Bytes.Encode as Encode
import Crypto exposing (getSecureContext, digest)
import Dict exposing (Dict)
import HttpServer as Http exposing (ServerError(..))
import HttpServer as Request
import HttpServer.Response as Response exposing (Response)
import Init
import Json.Decode as JsonDecode
import Json.Encode as JsonEncode
import Math
import Node
import Node exposing (Environment, Program)
import Stream
import Task exposing (Task)
import Url


main : Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }

encodeJsonBody : JsonEncode.Value -> String
encodeJsonBody data =
    JsonEncode.encode 0 <| JsonEncode.object [
        {
            key = "data",
            value = JsonEncode.object [{
                key = "attributes",
                value = data
            }]
        }
    ]



encodeUser : User -> JsonEncode.Value
encodeUser user =
    JsonEncode.object [
        { key = "first_name", value = JsonEncode.string user.firstName }
      , { key = "last_name", value = JsonEncode.string user.lastName }
      , { key = "email", value = JsonEncode.string user.email }
    ]


type alias User =
    {
      email: String,
      firstName: String,
      lastName: String,
      hashedPassword: String
    }

type alias UserDb = Dict String User
-- this should instead be a dict
-- {email=>User}

type alias Model =
    { appState : { userDb : UserDb }
    , server : Maybe Http.Server
    , stderr : Stream.Writable Bytes
    , stdout : Stream.Writable Bytes
    }


type Msg
    = CreateServerResult (Result Http.ServerError Http.Server)
    | GotRequest { request : Http.Request, response : Response }
    | GotSecureContext {
        context: Crypto.SecureContext
      , res: Response.Response
      , user: SignInRequestUser
    }
    | HashingFailed {error: String, res: Response.Response}
    | PasswordChecked {match: Bool, user: User, res: Response.Response}


init : Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    let dummyEmail = "nobody@test.com"
        userDb = Dict.empty |>
                    Dict.set
                        dummyEmail
                        {
                            email=dummyEmail,
                            firstName="Test",
                            hashedPassword="936a185caaa266bb9cbe981e9e05cb78cd732b0b3280eb944412bb6f8f8f07af",
                            lastName="User"
                        }
    in
        Init.await Http.initialize <| \serverPermission ->
            Node.startProgram
                { model =
                    {
                      appState = {userDb = userDb}
                    , server = Nothing
                    , stderr = env.stderr
                    , stdout = env.stdout
                    }

                , command =
                    Task.attempt CreateServerResult <|
                        Http.createServer serverPermission
                            { host = "localhost"
                            , port_ = 3000
                            }
                }


type alias SignInRequestUser =
    { email : String
    , password : String
    }

makeSignInRequestUser : String -> String -> SignInRequestUser
makeSignInRequestUser email password =
    { email = email
    , password = password
    }

signInBodyDecoder =
    Request.bodyFromJson (
        JsonDecode.map2 makeSignInRequestUser
        (JsonDecode.field "email" JsonDecode.string)
        (JsonDecode.field "password" JsonDecode.string)
    )

type alias SignUpRequestUser =
    { email : String
    , hashedPassword : String
    , firstName : String
    , lastName : String
    }

makeSignUpRequestUser : String -> String -> String -> String -> SignUpRequestUser
makeSignUpRequestUser email password firstName lastName =
    { email = email
    , firstName = firstName
    , hashedPassword = password
    , lastName = lastName
    }

signUpBodyDecoder =
    Request.bodyFromJson (
        JsonDecode.map4 makeSignUpRequestUser
        (JsonDecode.field "email" JsonDecode.string)
        (JsonDecode.field "firstName" JsonDecode.string)
        (JsonDecode.field "hashedPassword" JsonDecode.string)
        (JsonDecode.field "lastName" JsonDecode.string)
    )


errorResponse res code err =
  res
    |> Response.setStatus code
    |> Response.setHeader "Content-type" "text/html"
    |> Response.setBody ("<html>" ++ err ++ "</html>")
    |> Response.send

-- TODO: add opt headers dict
-- TODO: add opt content-type
successResponse res code contentType message =
  res
    |> Response.setStatus code
    |> Response.setHeader "Access-Control-Allow-Origin" "*"
    |> Response.setHeader "Access-Control-Allow-Methods" "POST"
    |> Response.setHeader "Access-Control-Allow-Headers" "*"
    |> Response.setHeader "Content-type" contentType
    |> Response.setBody (message)
    |> Response.send



signUpHandler : Model -> Request.Request -> Response.Response -> { model : Model, command : Cmd Msg }
signUpHandler model req res =
    let decodedData = (signUpBodyDecoder req)
    in
        when decodedData is
          -- TODO: hash user password *GROAN*
          Ok signUpRequestUser ->
              let email = signUpRequestUser.email
                  updatedUserDb = Dict.set email signUpRequestUser model.appState.userDb
                  updatedAppState = {model.appState | userDb = updatedUserDb}
              in
                Debug.log (Debug.toString updatedAppState)
                {
                    model={model | appState=updatedAppState}
                 ,  command = successResponse res 201 "text/html" <| "created user: " ++ email
                }
          Err error ->
            {
                model=model
                -- TODO: handle all Error enum values
                    -- Field
                    -- Index
                    -- OneOf
                    -- Failure
             ,  command = errorResponse res 400 <| JsonDecode.errorToString error
            }

hashPassword : Crypto.SecureContext -> String -> Task String Bytes
hashPassword context password =
    let
        passwordBytes = Bytes.fromString password
    in
        digest context Crypto.Sha256 passwordBytes |>
        Task.mapError (\_ -> "Hashing failed")

signInHandler : Model -> Request.Request -> Response.Response -> { model : Model, command : Cmd Msg }
signInHandler model req res =
    let decodedData = (signInBodyDecoder req)
    in
        when decodedData is
          Err error ->
            {
                model=model
                -- TODO: handle all Error enum values
                    -- Field
                    -- Index
                    -- OneOf
                    -- Failure
             ,  command = errorResponse res 400 <| JsonDecode.errorToString error
            }
          Ok signInRequestUser ->
            { model = model
            , command =
                Task.attempt
                    (\result ->
                        when result is
                            Ok context -> GotSecureContext {context=context, user=signInRequestUser, res=res}
                            Err error ->
                                -- Debug.log ("Unable to get secure context" ++ (Debug.toString error))
                                -- i don't think this is correct? this wouldn't be HashingFailed
                                -- but GetSecureContextFailed
                                HashingFailed {error="Failed to get secure context", res=res}
                    )
                    getSecureContext
            }


requestHandler : Model -> Request.Request -> Response.Response -> { model : Model, command : Cmd Msg }
requestHandler model req res =
    when req.method is
        Request.POST ->
            when req.url.path is
                "/users/auth/sign-up" ->
                    signUpHandler model req res
                "/users/auth/sign-in" ->
                    signInHandler model req res
                _ ->
                    {
                        command=errorResponse res 404 ""
                      , model=model
                    }
        Request.UNKNOWN method ->
            let unknownMethodError = "Unknown HTTP method: " ++ method
            in
                -- TODO: submit feature request / patch for this?
                if method == "OPTIONS" then
                    {
                        command=successResponse res 200 "text/html" ""
                      , model=model
                    }
                else
                    {
                        command=successResponse res 400 "text/html" unknownMethodError
                      , model=model
                    }
        _ ->
            {
                command=successResponse res 400 "text/html" "..."
              , model=model
            }

bytesToHex : Bytes -> String
bytesToHex bytes =
    let
        byteToHex : Int -> String
        byteToHex byte =
            let
                toHexDigit n =
                    if n < 10 then
                        String.fromInt n
                    else
                        when n is
                            10 -> "a"
                            11 -> "b"
                            12 -> "c"
                            13 -> "d"
                            14 -> "e"
                            15 -> "f"
                            _ -> "0"
                high = byte // 16
                low = Math.modBy 16 byte
            in
                toHexDigit high ++ toHexDigit low

        buildHexString : Int -> BytesDecode.Decoder String
        buildHexString remaining =
            if remaining <= 0 then
                BytesDecode.succeed ""
            else
                BytesDecode.map2 (\byte rest -> byteToHex byte ++ rest)
                    BytesDecode.unsignedInt8
                    (buildHexString (remaining - 1))

        decoder = buildHexString (Bytes.length bytes)
    in
        when BytesDecode.decode decoder bytes is
            Just hexString -> hexString
            Nothing -> ""

update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    when msg is
        CreateServerResult result ->
            when result is
                Ok server ->
                    { model = { model | server = Just server }
                    , command =
                        Stream.writeLineAsBytes "Server started" model.stdout
                           |> Task.onError (\_ -> Task.succeed model.stderr)
                           |> Task.execute
                    }
                Err (ServerError { code, message }) ->
                    { model = model
                    , command =
                        Stream.writeLineAsBytes ("Server failed to start: " ++ code ++ "\n" ++ message) model.stderr
                          |> Task.onError (\_ -> Task.succeed model.stderr)
                          |> Task.execute
                    }
        GotRequest { request = req, response = res } ->
            requestHandler model req res
        PasswordChecked passwordCheckValues -> -- dumb variable name but better than "stuff"
            when passwordCheckValues.match is
              True ->
                  let body = encodeJsonBody <| encodeUser passwordCheckValues.user
                  in
                    Debug.log "login succeeded"
                    {
                      command=successResponse passwordCheckValues.res 200 "application/json" body
                    , model=model
                    }
              False ->
                Debug.log "login failed"
                {
                   command=errorResponse passwordCheckValues.res 400 <| "login failed!"
                 , model=model
                }
        GotSecureContext {context=context, user=signInRequestUser, res=res} ->
            let
                user_ = Dict.get signInRequestUser.email model.appState.userDb
            in
            { model = model
            , command =
                Task.attempt
                    (\result ->
                        -- this is dumb and should be its own Msg
                        -- this nesting is also dumb
                        when user_ is
                            Just user__ ->
                                when result is
                                    Ok hashedBytes ->
                                        let
                                            hashedHex = bytesToHex hashedBytes
                                        in
                                            PasswordChecked {
                                                match=(hashedHex == user__.hashedPassword)
                                              , res=res
                                              , user=user__
                                            }
                                    Err _ ->
                                        HashingFailed {error="Password hashing failed", res=res}
                            Nothing ->
                                HashingFailed {error="No user to compare against", res=res}
                    )
                    (hashPassword context signInRequestUser.password)
            }
        -- This results in an inscrutable error:
        -- > thread blocked indefinitely in an MVar operation
        -- HashingFailed _ -> {model=model, command=Cmd.none}
        _ -> {model=model, command=Cmd.none}
subscriptions : Model -> Sub Msg
subscriptions model =
    when model.server is
        Just server ->
            Http.onRequest server (\req res -> GotRequest { request = req, response = res })
        Nothing ->
            Sub.none
