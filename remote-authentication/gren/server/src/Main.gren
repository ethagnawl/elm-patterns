module Main exposing (main)

import Bytes exposing (Bytes)
import BytesUtils exposing (bytesToHex)
import Crypto exposing (getSecureContext, digest)
import Dict exposing (Dict)
import HttpServer as Http exposing (ServerError(..))
import HttpServer as Request
import HttpServer.Response as Response exposing (Response)
import Init
import Json.Decode as JsonDecode
import Json.Encode as JsonEncode
import Math
import Node
import Node exposing (Environment, Program)
import Stream
import Task exposing (Task)
import Url


main : Program Model Msg
main =
    Node.defineProgram
        { init = init
        , subscriptions = subscriptions
        , update = update
        }

encodeJsonBody : JsonEncode.Value -> String
encodeJsonBody data =
    JsonEncode.encode 0 <| JsonEncode.object [
        {
            key = "data",
            value = JsonEncode.object [{
                key = "attributes",
                value = data
            }]
        }
    ]


encodeUser : User -> JsonEncode.Value
encodeUser user =
    JsonEncode.object [
        { key = "first_name", value = JsonEncode.string user.firstName }
      , { key = "last_name", value = JsonEncode.string user.lastName }
      , { key = "email", value = JsonEncode.string user.email }
    ]


type alias User =
    {
      email: String,
      firstName: String,
      lastName: String,
      hashedPassword: String
    }

type alias UserDb = Dict String User

type alias Model =
    { appState : { userDb : UserDb }
    , server : Maybe Http.Server
    , stderr : Stream.Writable Bytes
    , stdout : Stream.Writable Bytes
    }


type Msg
    = CreateServerResult (Result Http.ServerError Http.Server)
    | GotRequest { request : Http.Request, response : Response }
    | GotSecureContext {
        context: Crypto.SecureContext
      , res: Response.Response
      , user: SignInRequestUser
    }
    | HashingFailed {error: String, res: Response.Response}
    | PasswordChecked {match: Bool, user: User, res: Response.Response}


init : Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    let dummyEmail = "nobody@test.com"
        userDb = Dict.empty |>
                    Dict.set
                        dummyEmail
                        {
                            email=dummyEmail,
                            firstName="Test",
                            hashedPassword="936a185caaa266bb9cbe981e9e05cb78cd732b0b3280eb944412bb6f8f8f07af",
                            lastName="User"
                        }
    in
        Init.await Http.initialize <| \serverPermission ->
            Node.startProgram
                { model =
                    {
                      appState = {userDb = userDb}
                    , server = Nothing
                    , stderr = env.stderr
                    , stdout = env.stdout
                    }

                , command =
                    Task.attempt CreateServerResult <|
                        Http.createServer serverPermission
                            { host = "localhost"
                            , port_ = 3000
                            }
                }


type alias SignInRequestUser =
    { email : String
    , password : String
    }

makeSignInRequestUser : String -> String -> SignInRequestUser
makeSignInRequestUser email password =
    { email = email
    , password = password
    }

signInBodyDecoder =
    Request.bodyFromJson (
        JsonDecode.map2 makeSignInRequestUser
        (JsonDecode.field "email" JsonDecode.string)
        (JsonDecode.field "password" JsonDecode.string)
    )

type alias SignUpRequestUser =
    { email : String
    , hashedPassword : String
    , firstName : String
    , lastName : String
    }

makeSignUpRequestUser : String -> String -> String -> String -> SignUpRequestUser
makeSignUpRequestUser email password firstName lastName =
    { email = email
    , firstName = firstName
    , hashedPassword = password
    , lastName = lastName
    }

signUpBodyDecoder =
    Request.bodyFromJson (
        JsonDecode.map4 makeSignUpRequestUser
        (JsonDecode.field "email" JsonDecode.string)
        (JsonDecode.field "firstName" JsonDecode.string)
        (JsonDecode.field "hashedPassword" JsonDecode.string)
        (JsonDecode.field "lastName" JsonDecode.string)
    )


errorResponse res code err =
  res
    |> Response.setStatus code
    |> Response.setHeader "Content-type" "text/plain"
    |> Response.setBody err
    |> Response.send

successResponse res code contentType headers message =
    let
        baseResponse = res
            |> Response.setStatus code
            |> Response.setHeader "Content-Type" contentType
            |> Response.setHeader "Access-Control-Allow-Origin" "*"
            |> Response.setHeader "Access-Control-Allow-Methods" "POST"
            |> Response.setHeader "Access-Control-Allow-Headers" "*"
            |> Response.setHeader "Content-type" contentType
            |> Response.setBody message
        finalResponse = when headers is
            Just newHeaders ->
                let
                    result = Dict.foldl
                        (\key value currentResponse -> Response.setHeader key value currentResponse)
                        baseResponse
                        newHeaders
                in
                    result
            Nothing ->
                baseResponse
    in
        Response.send finalResponse


signUpHandler : Model -> Request.Request -> Response.Response -> { model : Model, command : Cmd Msg }
signUpHandler model req res =
    let decodedData = (signUpBodyDecoder req)
    in
        when decodedData is
          -- TODO: hash user password *GROAN*
          Ok signUpRequestUser ->
              let email = signUpRequestUser.email
                  updatedUserDb = Dict.set email signUpRequestUser model.appState.userDb
                  updatedAppState = {model.appState | userDb = updatedUserDb}
              in
                Debug.log (Debug.toString updatedAppState)
                {
                    model={model | appState=updatedAppState}
                 ,  command = successResponse res 201 "text/plain" Nothing <| "created user: " ++ email
                }
          Err error ->
            {
                model=model
                -- TODO: handle all Error enum values
                    -- Field
                    -- Index
                    -- OneOf
                    -- Failure
             ,  command = errorResponse res 400 <| JsonDecode.errorToString error
            }

hashPassword : Crypto.SecureContext -> String -> Task String Bytes
hashPassword context password =
    let
        passwordBytes = Bytes.fromString password
    in
        digest context Crypto.Sha256 passwordBytes |>
        Task.mapError (\_ -> "Hashing failed")

signInHandler : Model -> Request.Request -> Response.Response -> { model : Model, command : Cmd Msg }
signInHandler model req res =
    let decodedData = (signInBodyDecoder req)
    in
        when decodedData is
          Err error ->
            {
                model=model
                -- TODO: handle all Error enum values
                    -- Field
                    -- Index
                    -- OneOf
                    -- Failure
             ,  command = errorResponse res 400 <| JsonDecode.errorToString error
            }
          Ok signInRequestUser ->
            { model = model
            , command =
                Task.attempt
                    (\result ->
                        when result is
                            Ok context -> GotSecureContext {context=context, user=signInRequestUser, res=res}
                            Err error ->
                                -- Debug.log ("Unable to get secure context" ++ (Debug.toString error))
                                -- i don't think this is correct? this wouldn't be HashingFailed
                                -- but GetSecureContextFailed
                                HashingFailed {error="Failed to get secure context", res=res}
                    )
                    getSecureContext
            }


corsHandler model req res =
    -- all XHR requests need the CORS headers, so this winds up being pretty useless ...
    let corsHeaders = Nothing
    in
        {
            command=successResponse res 200 "text/plain" corsHeaders ""
          , model=model
        }

requestHandler : Model -> Request.Request -> Response.Response -> { model : Model, command : Cmd Msg }
requestHandler model req res =
    when req.method is
        Request.POST ->
            when req.url.path is
                "/users/auth/sign-up" ->
                    signUpHandler model req res
                "/users/auth/sign-in" ->
                    signInHandler model req res
                _ ->
                    {
                        command=errorResponse res 404 ""
                      , model=model
                    }
        Request.UNKNOWN method ->
            let unknownMethodError = "Unknown HTTP method: " ++ method
            in
                -- TODO: submit feature request / patch for this?
                if method == "OPTIONS" then
                    corsHandler model req res
                else
                    {
                        command=successResponse res 400 "text/plain" Nothing unknownMethodError
                      , model=model
                    }
        _ ->
            {
                command=successResponse res 400 "text/plain" Nothing "..."
              , model=model
            }

bytesToHex : Bytes -> String
bytesToHex bytes =
    let
        byteToHex : Int -> String
        byteToHex byte =
            let
                toHexDigit n =
                    if n < 10 then
                        String.fromInt n
                    else
                        when n is
                            10 -> "a"
                            11 -> "b"
                            12 -> "c"
                            13 -> "d"
                            14 -> "e"
                            15 -> "f"
                            _ -> "0"
                high = byte // 16
                low = Math.modBy 16 byte
            in
                toHexDigit high ++ toHexDigit low

        buildHexString : Int -> BytesDecode.Decoder String
        buildHexString remaining =
            if remaining <= 0 then
                BytesDecode.succeed ""
            else
                BytesDecode.map2 (\byte rest -> byteToHex byte ++ rest)
                    BytesDecode.unsignedInt8
                    (buildHexString (remaining - 1))

        decoder = buildHexString (Bytes.length bytes)
    in
        when BytesDecode.decode decoder bytes is
            Just hexString -> hexString
            Nothing -> ""

update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    when msg is
        CreateServerResult result ->
            when result is
                Ok server ->
                    { model = { model | server = Just server }
                    , command =
                        Stream.writeLineAsBytes "Server started" model.stdout
                           |> Task.onError (\_ -> Task.succeed model.stderr)
                           |> Task.execute
                    }
                Err (ServerError { code, message }) ->
                    { model = model
                    , command =
                        Stream.writeLineAsBytes ("Server failed to start: " ++ code ++ "\n" ++ message) model.stderr
                          |> Task.onError (\_ -> Task.succeed model.stderr)
                          |> Task.execute
                    }
        GotRequest { request = req, response = res } ->
            requestHandler model req res
        PasswordChecked passwordCheckValues -> -- dumb variable name but better than "stuff"
            when passwordCheckValues.match is
              True ->
                  let body = encodeJsonBody <| encodeUser passwordCheckValues.user
                  in
                    Debug.log "login succeeded"
                    {
                      command=successResponse passwordCheckValues.res 200 "application/json" Nothing body
                    , model=model
                    }
              False ->
                Debug.log "login failed"
                {
                   command=errorResponse passwordCheckValues.res 400 <| "login failed!"
                 , model=model
                }
        GotSecureContext {context=context, user=signInRequestUser, res=res} ->
            let
                user_ = Dict.get signInRequestUser.email model.appState.userDb
            in
            { model = model
            , command =
                Task.attempt
                    (\result ->
                        -- this is dumb and should be its own Msg
                        -- this nesting is also dumb
                        when user_ is
                            Just user__ ->
                                when result is
                                    Ok hashedBytes ->
                                        let
                                            hashedHex = bytesToHex hashedBytes
                                            match = (hashedHex == user__.hashedPassword)
                                        in
                                            PasswordChecked {
                                                match=match
                                              , res=res
                                              , user=user__
                                            }
                                    Err _ ->
                                        HashingFailed {error="Password hashing failed", res=res}
                            Nothing ->
                                HashingFailed {error="No user to compare against", res=res}
                    )
                    (hashPassword context signInRequestUser.password)
            }
        -- This results in an inscrutable error:
        -- > thread blocked indefinitely in an MVar operation
        -- HashingFailed _ -> {model=model, command=Cmd.none}
        _ -> {model=model, command=Cmd.none}
subscriptions : Model -> Sub Msg
subscriptions model =
    when model.server is
        Just server ->
            Http.onRequest server (\req res -> GotRequest { request = req, response = res })
        Nothing ->
            Sub.none
