module Main exposing (main)

import Bytes exposing (Bytes)
import Bytes.Decode as BytesDecode
import Bytes.Encode as Encode
import Crypto exposing (getSecureContext, digest)
import HttpServer as Http exposing (ServerError(..))
import HttpServer as Request
import HttpServer.Response as Response exposing (Response)
import Init
import Json.Decode as Decode exposing (..)
import Math
import Node
import Node exposing (Environment, Program)
import Stream
import Task exposing (Task)
import Url


main : Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }

type alias User =
    {
      email: String,
      firstName: String,
      lastName: String,
      hashedPassword: String
    }

type alias UserDb = Array User
-- this should instead be a dict
-- {email=>User}

type alias Model =
    { appState : { userDb : UserDb }
    , server : Maybe Http.Server
    , stderr : Stream.Writable Bytes
    , stdout : Stream.Writable Bytes
    }


type Msg
    = CreateServerResult (Result Http.ServerError Http.Server)
    | GotRequest { request : Http.Request, response : Response }
    | GotSecureContext {
        context: Crypto.SecureContext
      , res: Response.Response
      , user: SignInRequestUser
    }
    | HashingFailed {error: String, res: Response.Response}
    | PasswordChecked {match: Bool, res: Response.Response}


init : Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await Http.initialize <| \serverPermission ->
        Node.startProgram
            { model =
                { stdout = env.stdout
                , stderr = env.stderr
                , server = Nothing
                , appState = {userDb = [
                        {
                            email="nobody@test.com"
                          , firstName="nobody"
                          , hashedPassword="936a185caaa266bb9cbe981e9e05cb78cd732b0b3280eb944412bb6f8f8f07af" -- helloworld
                          , lastName="nobody"
                        }
                    ]}
                }
            , command =
                Task.attempt CreateServerResult <|
                    Http.createServer serverPermission
                        { host = "0.0.0.0"
                        , port_ = 3000
                        }
            }


type alias SignInRequestUser =
    { email : String
    , password : String
    }

makeSignInRequestUser : String -> String -> SignInRequestUser
makeSignInRequestUser email password =
    { email = email
    , password = password
    }

signInBodyDecoder =
    Request.bodyFromJson (
        Decode.map2 makeSignInRequestUser
        (Decode.field "email" Decode.string)
        (Decode.field "password" Decode.string)
    )

type alias SignUpRequestUser =
    { email : String
    , password : String
    , firstName : String
    , lastName : String
    }

makeSignUpRequestUser : String -> String -> String -> String -> SignUpRequestUser
makeSignUpRequestUser email password firstName lastName =
    { email = email
    , password = password
    , firstName = firstName
    , lastName = lastName
    }

signUpBodyDecoder =
    Request.bodyFromJson (
        Decode.map4 makeSignUpRequestUser
        (Decode.field "email" Decode.string)
        (Decode.field "password" Decode.string)
        (Decode.field "firstName" Decode.string)
        (Decode.field "lastName" Decode.string)
    )


errorResponse res code err =
  res
    |> Response.setStatus code
    |> Response.setHeader "Content-type" "text/html"
    |> Response.setBody ("<html>" ++ err ++ "</html>")
    |> Response.send

successResponse res code message =
  res
    |> Response.setStatus code
    |> Response.setHeader "Content-type" "text/html"
    |> Response.setBody ("<html>" ++ message ++ "</html>")
    |> Response.send



signUpHandler : Model -> Request.Request -> Response.Response -> { model : Model, command : Cmd Msg }
signUpHandler model req res =
    let decodedData = (signUpBodyDecoder req)
    in
        when decodedData is
          -- TODO: hash user password *GROAN* and add user to appState
          Ok signUpRequestUser ->
            {
                model=model
             ,  command = successResponse res 201 <| "created user: " ++ signUpRequestUser.email
            }
          Err error ->
            {
                model=model
                -- TODO: handle all Error enum values
                    -- Field
                    -- Index
                    -- OneOf
                    -- Failure
             ,  command = errorResponse res 400 <| Decode.errorToString error
            }

hashPassword : Crypto.SecureContext -> String -> Task String Bytes
hashPassword context password =
    let
        passwordBytes = Bytes.fromString password
    in
        digest context Crypto.Sha256 passwordBytes |>
        Task.mapError (\_ -> "Hashing failed")

signInHandler : Model -> Request.Request -> Response.Response -> { model : Model, command : Cmd Msg }
signInHandler model req res =
    let decodedData = (signInBodyDecoder req)
    in
        when decodedData is
          Err error ->
            {
                model=model
                -- TODO: handle all Error enum values
                    -- Field
                    -- Index
                    -- OneOf
                    -- Failure
             ,  command = errorResponse res 400 <| Decode.errorToString error
            }
          Ok signInRequestUser ->
            { model = model
            , command =
                Task.attempt
                    (\result ->
                        when result is
                            Ok context -> GotSecureContext {context=context, user=signInRequestUser, res=res}
                            Err error ->
                                -- Debug.log ("Unable to get secure context" ++ (Debug.toString error))
                                -- i don't think this is correct? this wouldn't be HashingFailed
                                -- but GetSecureContextFailed
                                HashingFailed {error="Failed to get secure context", res=res}
                    )
                    getSecureContext
            }


requestHandler : Model -> Request.Request -> Response.Response -> { model : Model, command : Cmd Msg }
requestHandler model req res =
    when req.method is
        Request.POST ->
            when req.url.path is
                "/users/auth/sign-up" ->
                    signUpHandler model req res
                "/users/auth/sign-in" ->
                    signInHandler model req res
                _ ->
                    {model=model, command=errorResponse res 404 "fixme"}
        _ ->
            {model=model, command=errorResponse res 404 "fixme"}

bytesToHex : Bytes -> String
bytesToHex bytes =
    let
        byteToHex : Int -> String
        byteToHex byte =
            let
                toHexDigit n =
                    if n < 10 then
                        String.fromInt n
                    else
                        when n is
                            10 -> "a"
                            11 -> "b"
                            12 -> "c"
                            13 -> "d"
                            14 -> "e"
                            15 -> "f"
                            _ -> "0"
                high = byte // 16
                low = Math.modBy 16 byte
            in
                toHexDigit high ++ toHexDigit low

        buildHexString : Int -> BytesDecode.Decoder String
        buildHexString remaining =
            if remaining <= 0 then
                BytesDecode.succeed ""
            else
                BytesDecode.map2 (\byte rest -> byteToHex byte ++ rest)
                    BytesDecode.unsignedInt8
                    (buildHexString (remaining - 1))

        decoder = buildHexString (Bytes.length bytes)
    in
        when BytesDecode.decode decoder bytes is
            Just hexString -> hexString
            Nothing -> ""

update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    when msg is
        CreateServerResult result ->
            when result is
                Ok server ->
                    { model = { model | server = Just server }
                    , command =
                        Stream.writeLineAsBytes "Server started" model.stdout
                           |> Task.onError (\_ -> Task.succeed model.stderr)
                           |> Task.execute
                    }
                Err (ServerError { code, message }) ->
                    { model = model
                    , command =
                        Stream.writeLineAsBytes ("Server failed to start: " ++ code ++ "\n" ++ message) model.stderr
                          |> Task.onError (\_ -> Task.succeed model.stderr)
                          |> Task.execute
                    }

        GotRequest { request = req, response = res } ->
            requestHandler model req res
        PasswordChecked passwordCheckValues -> -- dumb variable name but better than "stuff"
            when passwordCheckValues.match is
              True ->
                Debug.log "login succeeded"
                {
                  model=model
                , command=successResponse passwordCheckValues.res 200 <| "login succeeded!"
                }
              False ->
                Debug.log "login failed"
                {
                  model=model
                , command=errorResponse passwordCheckValues.res 400 <| "login failed!"
                }

        GotSecureContext {context=context, user=signInRequestUser, res=res} ->
            let
                user_ = Array.first model.appState.userDb
                storedHash =
                    when user_ is
                        Just user__ -> user__.hashedPassword
                        _ -> "..." -- this is not okay; this should result in an error
            in
            { model = model
            , command =
                Task.attempt
                    (\result ->
                        when result is
                            Ok hashedBytes ->
                                let
                                    hashedHex = bytesToHex hashedBytes
                                in
                                    PasswordChecked {
                                        match=(hashedHex == storedHash)
                                      , res=res
                                    }
                            Err _ ->
                                HashingFailed {error="Password hashing failed", res=res}
                    )
                    (hashPassword context signInRequestUser.password)
            }
        -- This results in an inscrutable error:
        -- > thread blocked indefinitely in an MVar operation
        -- HashingFailed _ -> {model=model, command=Cmd.none}
        _ -> {model=model, command=Cmd.none}
subscriptions : Model -> Sub Msg
subscriptions model =
    when model.server is
        Just server ->
            Http.onRequest server (\req res -> GotRequest { request = req, response = res })
        Nothing ->
            Sub.none
